import{_ as s,c as i,a2 as a,o as n}from"./chunks/framework.BQmytedh.js";const u=JSON.parse('{"title":"Common Issues","description":"","frontmatter":{},"headers":[],"relativePath":"docs/misc/common-issues.md","filePath":"docs/misc/common-issues.md","lastUpdated":1714807325000}'),o={name:"docs/misc/common-issues.md"};function t(l,e,r,d,h,p){return n(),i("div",null,e[0]||(e[0]=[a('<h1 id="common-issues" tabindex="-1">Common Issues <a class="header-anchor" href="#common-issues" aria-label="Permalink to &quot;Common Issues&quot;">​</a></h1><p>This page covers a few common issues that you may face, when developing mods for Sapiens.</p><h2 id="copy-pasting-files" tabindex="-1">Copy/Pasting Files <a class="header-anchor" href="#copy-pasting-files" aria-label="Permalink to &quot;Copy/Pasting Files&quot;">​</a></h2><p>Sapiens modding requires a special kind of coding style called <a href="/guide/shadowing.html">shadowing</a>. This is <em>required</em>. If you just copy/paste source files into your mod and edit them, they won&#39;t have any effect at all!</p><h2 id="running-server-logic-on-app-mods" tabindex="-1">Running Server logic on App Mods <a class="header-anchor" href="#running-server-logic-on-app-mods" aria-label="Permalink to &quot;Running Server logic on App Mods&quot;">​</a></h2><p>There are two <a href="/docs/engine/mod-types.html">mod types</a> in Sapiens: app mods and world mods. You must be aware of the limitation that doesn&#39;t allow App Mods to operate on the server thread. If you need the server thread, make a world mod instead.</p><h2 id="confusing-module-function-with-module-function" tabindex="-1">Confusing <code>module.function()</code> with <code>module:function()</code> <a class="header-anchor" href="#confusing-module-function-with-module-function" aria-label="Permalink to &quot;Confusing `module.function()` with `module:function()`&quot;">​</a></h2><p>In lua, you define a module like <code>local foo = {}</code>. Functions can then be defined like:</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg1)</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	...</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>This is a shorthand for the longer form (don&#39;t use this except for shadows)</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, arg1)</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	...</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>As you can see, there is a mysterious &#39;self&#39; argument getting passed around when using the <code>:</code> syntax. This roughly represents the current object (?).</p><p>Now imagine that you&#39;ve defined a function as in the first example, and then attempted to call it like this:</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;baz&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>This would be incorrect, since you&#39;ve essentially put &#39;baz&#39; for &#39;self&#39; and &#39;nil&#39; for &#39;arg1&#39;. The correct way to call it would be <code>local value = foo:bar(&#39;baz&#39;)</code>.</p><h2 id="recursive-mjrequire" tabindex="-1">Recursive <code>mjrequire</code> <a class="header-anchor" href="#recursive-mjrequire" aria-label="Permalink to &quot;Recursive `mjrequire`&quot;">​</a></h2><p>If you have <code>foo.lua</code> which requires <code>bar.lua</code>, then you can&#39;t require <code>bar.lua</code> in <code>foo.lua</code> because it would cause an infinite loop.</p><p>Workarounds:</p><ul><li>mjrequire inside of Functions</li><li>rework your architecture</li><li>pass <code>bar</code> as a parameter to <code>foo</code> (init function)</li></ul>',19)]))}const k=s(o,[["render",t]]);export{u as __pageData,k as default};
