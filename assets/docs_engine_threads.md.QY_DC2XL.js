import{_ as e,c as a,o as t,a3 as o}from"./chunks/framework.COm4hYgr.js";const g=JSON.parse('{"title":"Thread Management","description":"","frontmatter":{},"headers":[],"relativePath":"docs/engine/threads.md","filePath":"docs/engine/threads.md","lastUpdated":1714807325000}'),r={name:"docs/engine/threads.md"},n=o('<h1 id="thread-management" tabindex="-1">Thread Management <a class="header-anchor" href="#thread-management" aria-label="Permalink to &quot;Thread Management&quot;">​</a></h1><p>Sapiens uses multiple threads to manage tasks. These threads are more or less reflected in the folder structure of the Lua code. For example, code nested within <code>server</code> will only be executed on the server, and so forth.</p><h2 id="threads-explained" tabindex="-1">Threads Explained <a class="header-anchor" href="#threads-explained" aria-label="Permalink to &quot;Threads Explained&quot;">​</a></h2><p>Each thread has its own separate Lua enviornment, so you can&#39;t just call functions directly in other threads or anything like that. While it is resource heavy for sure, the developer decided it was the best solution. There are 4 Lua enviroments:</p><ul><li><strong>server</strong>: server-side thread</li><li><strong>mainThread</strong>: client-side thread, sometimes called the &#39;client&#39;</li><li><strong>logicThread</strong>: secondary client-side thread, does anything that doesn&#39;t require immediate feedback to the player</li><li><strong>globeThread</strong>: which is only used to render the globe in the main menu</li></ul><p>The <strong>globeThread</strong> only runs in the main menu/world creation, so there is a maximum of 3 threads running at once</p><h2 id="available-threads" tabindex="-1">Available Threads <a class="header-anchor" href="#available-threads" aria-label="Permalink to &quot;Available Threads&quot;">​</a></h2><p>Here is a quick explanation of all threads.</p><h3 id="server" tabindex="-1">server <a class="header-anchor" href="#server" aria-label="Permalink to &quot;server&quot;">​</a></h3><p>The <code>server</code> thread runs the client-agnostic logic. Sapiens is a multiplayer game, where multiple clients can attach to the same server. This means the server thread <strong>cannot</strong> be assumed to be running on the same physical machine as the other threads.</p><p>For example, if a client (a player) digs out a section of the world, this will need to be communicated to all clients (all players, including the one digging). This will be done via the server (and the logic runs on the server thread).</p><p>Lua scripts that only run on the server can be found in <code>scripts/server</code></p><h3 id="mainthread" tabindex="-1">mainThread <a class="header-anchor" href="#mainthread" aria-label="Permalink to &quot;mainThread&quot;">​</a></h3><p>The <code>mainThread</code> does the rendering, handles UI, player movement, anything that needs immediate feedback to the user. You can think of the <code>mainThread</code> as the client.</p><p>Lua scripts that only run on the main thread can be found in <code>scripts/mainThread</code></p><h3 id="logicthread" tabindex="-1">logicThread <a class="header-anchor" href="#logicthread" aria-label="Permalink to &quot;logicThread&quot;">​</a></h3><p>The <code>logicThread</code> is a secondary client-side thread, which handles handles everything else on the client, generating terrain, updating buffers for rendering, updating animations, communications with the server. Basically, everything that doesn&#39;t require immediate feedback for the user, or may take a long time (if they happened on the mainThread, the game would appear unresponsive).</p><p>Lua scripts that only run on the logic thread can be found <code>scripts/logicThread</code></p><h3 id="globethread" tabindex="-1">globeThread <a class="header-anchor" href="#globethread" aria-label="Permalink to &quot;globeThread&quot;">​</a></h3><p>The <code>globe</code> thread is only used to render the globe in the main menu, so not relevant for gameplay code.</p><p>Lua scripts that will only run on the globe thread can be found in <code>scripts/globeThread</code>. There isn&#39;t much, because <a href="/docs/scripting/worldgen.html">world generation</a> is handled with C/C++.</p><div class="tip custom-block"><p class="custom-block-title">What&#39;s with this &#39;common&#39; folder?</p><p>The &#39;common&#39; folder in Sapiens contains a collection of files that can be accessed from multiple threads. These are usually shared stateful systems which need to be synced across multiple threads.</p></div><h2 id="thread-communication" tabindex="-1">Thread Communication <a class="header-anchor" href="#thread-communication" aria-label="Permalink to &quot;Thread Communication&quot;">​</a></h2><p>Sapiens has an RPC-like structure for elevating client calls to the server, and for server calls to be multicast to the clients. The only supported way to communicate between threads is the <code>callMainThreadFunction</code>/<code>registerMainThreadFunction</code> types of methods.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>You can only send one param at once! Use a table if you must process multiple pieces of information at once.</p></div><h3 id="client-server" tabindex="-1">Client -&gt; Server <a class="header-anchor" href="#client-server" aria-label="Permalink to &quot;Client -&gt; Server&quot;">​</a></h3><p>To communicate for the client to the server, you will need to register a new net function (at startup), then call it.</p><ul><li><code>server:registerNetFunction</code> can be called on the <code>server</code> to make a server function available to the <code>mainThread</code>.</li><li><code>logicInterface:callServerFunction</code> can be called on the <code>mainThread</code> to fire a function on the <code>server</code>, assuming <code>registerNetFunction</code> is setup.</li></ul><h3 id="server-client" tabindex="-1">Server -&gt; Client <a class="header-anchor" href="#server-client" aria-label="Permalink to &quot;Server -&gt; Client&quot;">​</a></h3><p>To communicate from the Server to the Client, you will need to do a bit of setup. The message will have to travel from: <code>server</code> -&gt; <code>logicThread</code> -&gt; <code>mainThread</code></p><ul><li><code>logic:registerLogicThreadNetFunction</code> can be used to register a <code>logicThread</code> function as callable on the server.</li><li><code>logicInterface:registerMainThreadFunction</code> can be used to register a <code>mainThread</code> function as callable on the logic thread.</li></ul><p>And then finally, you can use:</p><ul><li><code>server:callClientFunction</code> can be called on the <code>server</code> to propagate a server call to the <code>mainThread</code>, via the <code>logic</code> thread.</li></ul><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Lua objects need to be serialized/deserialized when those methods are called, and that can be a performance bottleneck if abused too much.</p></div>',34),i=[n];function s(d,l,c,h,u,m){return t(),a("div",null,i)}const b=e(r,[["render",s]]);export{g as __pageData,b as default};
