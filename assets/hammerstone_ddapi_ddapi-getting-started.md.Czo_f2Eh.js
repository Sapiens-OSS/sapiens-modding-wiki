import{_ as e,c as a,o as t,a4 as s}from"./chunks/framework.qL1yNBZ5.js";const g=JSON.parse('{"title":"Hammerstone Data-Driven-API","description":"","frontmatter":{},"headers":[],"relativePath":"hammerstone/ddapi/ddapi-getting-started.md","filePath":"hammerstone/ddapi/ddapi-getting-started.md","lastUpdated":1691841594000}'),i={name:"hammerstone/ddapi/ddapi-getting-started.md"},n=s(`<h1 id="hammerstone-data-driven-api" tabindex="-1">Hammerstone Data-Driven-API <a class="header-anchor" href="#hammerstone-data-driven-api" aria-label="Permalink to &quot;Hammerstone Data-Driven-API&quot;">​</a></h1><p>The &#39;DDAPI&#39; is a data-driven API for creating Hammerstone mods: rather than working with the games code directly, you&#39;re instead authoring a &quot;config&quot; format which Hammerstone interprets.</p><p>Writing config files can be done in two formats: Lua and JSON. Both are fully supported, yet the differences are that the json file has a light additional wrapper layer on the outside and a web editor; while Lua can add logic inside (useful for defining a template for instance).</p><p>Unless stated otherwise, DDAPI examples use the JSON format.</p><h3 id="philosophy" tabindex="-1">Philosophy <a class="header-anchor" href="#philosophy" aria-label="Permalink to &quot;Philosophy&quot;">​</a></h3><p>In the base game of Sapiens, the data and logic for a &quot;feature&quot; is often spread across multiple files. For example, to create an apple, you might need the following:</p><ul><li><code>gameObject.lua</code> - Define the apple object</li><li><code>resource.lua</code> - Give it a &#39;resource&#39; definition for storage/crafting</li><li><code>evolvingObject.lua</code> - Allow the apple to &#39;rot&#39; away, or into a rotten variant</li><li><code>storage.lua</code> - Allow the apple to be carried and stored in storage areas</li><li>... and more!</li></ul><p>With Hammerstone, we reverse this relationship. We believe you should be able to define your data in a single place, with a well-defined API. To create an apple in Hammerstone, you would only need to create <code>apple.json</code>.</p><p>Inside this apple file, you define &quot;components&quot; describing the apple. For example, this component allows the apple to &#39;rot&#39; into a rotten apple after some time:</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hs_evolving_object&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	&quot;min_time&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;5&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	&quot;category&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;rot&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	&quot;transform_to&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">		&quot;rotten_apple&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="config-types" tabindex="-1">Config Types <a class="header-anchor" href="#config-types" aria-label="Permalink to &quot;Config Types&quot;">​</a></h3><p>At it&#39;s core, Hammerstone is a <em>json based API</em>. The reason we chose json is because it&#39;s a data-exchange format. That means there are a lot of tools like json schemas which we can leverage. If you use our schemas you can get in-editor autocomplete, documentation, tool-tips, and linting.</p><p>However json isn&#39;t the best for complex items, which might require some programmatic-handling. In these cases you can also define your items in lua. We will read these lua files and evaluate them as such.</p><h1 id="getting-started-with-ddapi" tabindex="-1">Getting Started with DDAPI <a class="header-anchor" href="#getting-started-with-ddapi" aria-label="Permalink to &quot;Getting Started with DDAPI&quot;">​</a></h1><p>To get started, you need a live copy of Hammerstone beta, and a text editor like VSCode. Then create a folder structure like this:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mod-name</span></span>
<span class="line"><span>	modInfo.lua</span></span>
<span class="line"><span>	hammerstone</span></span>
<span class="line"><span>		objects</span></span>
<span class="line"><span>			my_object.json</span></span></code></pre></div>`,16),o=[n];function l(p,r,h,d,c,m){return t(),a("div",null,o)}const k=e(i,[["render",l]]);export{g as __pageData,k as default};
